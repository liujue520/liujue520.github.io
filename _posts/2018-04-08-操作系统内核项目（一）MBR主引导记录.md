---
layout:     post
title:      操作系统内核项目（一）
subtitle:   MBR主引导记录
date:       2018-04-08
author:     liujue
header-img: img/1/post-bg-android.jpg
catalog: true
tags:
    - 操作系统
---

加电以后CPU的CS:IP寄存器指向程序的起始地址，启动BIOS。加电以后内存处于实模式下，16位CPU的地址线为20位，故可以访问IMB的内存空间。是0x00000 到0xFFFFF。

低地址的0x00000~09XFFFF为DRAM，空间范围为640KB，顶部0XF0000~0XFFFFF，64KB为ROM，存的是BIOS的代码，直接调用就好了。这部分只保证了计算机能够运行的硬件的基本IO操作，建立了中断向量表。

# BIOS的启动与退出

加电以后CPU的CS:IP寄存器强制初始化为0XF000:0XFFF0,上面说了加电以后的CPU处于实模式，在实模式下的段基址要左移动4位，于是0XF000:0XFFF0的等效地址为0XFFFF0，记住这个数。这个地址就是BIOS的入口。而入口处对应为跳转指令，执行该指令后段基址左移4位,即跳到0XFE05B处，这是BIOS代码开始的地方。

BIOS执行的操作有检测内存、显卡等外设信息，检测通过，并初始化硬件以后，在内存0X000~0X3FF处创建数据结构，中断向量表，并且填写中断例程。

BIOS最后一项工作就是启动盘中位于0盘0道1扇区的内容，这个扇区颗末尾的两个字节分别是0X55和0Xaa，BIOS便认为此扇区中确实存在可执行的程序。便加载到物理地址0X7C00，随后跳转到此地址，继续执行。

jmp 0: 0x7c00
# MBR

MBR 本身也是程序，是程序就要用到栈，栈也是在内存中的，MBRR 虽然本身只有512 宇节，但还要为其所用的栈分配点空间，所以其实际所用的内存空间要大于512 字节，估计IKB 内存够用了。结合以上三点，选择32KB 中的最后IKB 最为合适，那此地址是多少呢？ 32KB 换算为十六进制为0x8000,减去1KB（0x400）等于0x7c000，
这就是倍受质疑的0x7c00 的由来。大小必须是512 字节，这是为了保证0x55 和0x跑这两个恰好出现在该扇区的最后两个字节处，即第510 字节处和第511 字节处，这是按起始偏移为0 算起的。

;主引导程序 
SECTION MBR vstart=0x7c00         
   mov ax,cs      
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00

   mov     ax, 0x600
   mov     bx, 0x700
   mov     cx, 0           
   mov     dx, 0x184f	  	
		  
   int     0x10          

   mov ah, 3	
   mov bh, 0	

   int 0x10	

   mov ax, message 
   mov bp, ax		

   mov cx, 5		
   mov ax, 0x1301	
			
   mov bx, 0x2		

   int 0x10		

   jmp $

   message db "1 MBR"
   times 510-($-$$) db 0
   db 0x55,0xaa
简短说一下代码功能，在屏幕上打印字符串“ l MBR ”， 背景色为黑色，前景色为绿色。0X10 中断是最为强大的BIOS 中断了，调用的方法是把功能号送入ah寄存器，其他参数按照BIOS 中断手册的要求放在适当的寄存器中，随后执行int 0X10 即可。

不用太细致琢磨BIOS 功能调用了，这里用BIOS 中断只是临时的，以后也用不到了。

vstart=0x7c00表示本程序的起始地址编译为0X7c00,因为CS这个时候为0，因为BIOS通过上面的命令跳到MBR，通过寄存器AX中转，将ds,es,ss,fs,gs等sreg初始化。

接着用mov sp,0x7c00初始化栈指针，将0X7c00以下作为栈来使用。

接着清除BIOS输出，获取光标位置，在BH寄存器中写入0,获取第0页当前的光标。

接着在光标处打印字符，调用0X13号子功能，01对应AL寄存器。0、1、2、3分别对应一个功能。接着一个死循环，然后接着打印的字符串。

$$-$为偏移量，510减去$$-$为本扇区的剩余量，用0填满剩余空间。